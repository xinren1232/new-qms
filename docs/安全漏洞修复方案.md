# QMS-AI系统安全漏洞修复方案

## 🚨 高优先级安全漏洞修复

### 1. JWT认证机制标准化

#### 当前问题
```javascript
// 存在安全漏洞的Token验证
function verifyToken(token) {
  try {
    const payload = JSON.parse(Buffer.from(token, 'base64').toString());
    if (payload.exp < Date.now()) {
      return null; // 仅检查过期时间，没有签名验证
    }
    return payload;
  } catch (error) {
    return null;
  }
}
```

#### 修复方案
```javascript
// 安装依赖
npm install jsonwebtoken bcryptjs

// 标准JWT实现
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');

const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-key-change-in-production';
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';

// 生成Token
function generateToken(user) {
  return jwt.sign(
    {
      userId: user.id,
      username: user.username,
      roles: user.roles
    },
    JWT_SECRET,
    {
      expiresIn: JWT_EXPIRES_IN,
      issuer: 'qms-ai-system',
      audience: 'qms-ai-users'
    }
  );
}

// 验证Token
function verifyToken(token) {
  try {
    return jwt.verify(token, JWT_SECRET, {
      issuer: 'qms-ai-system',
      audience: 'qms-ai-users'
    });
  } catch (error) {
    console.error('Token验证失败:', error.message);
    return null;
  }
}

// 密码加密
async function hashPassword(password) {
  const saltRounds = 12;
  return await bcrypt.hash(password, saltRounds);
}

// 密码验证
async function verifyPassword(password, hashedPassword) {
  return await bcrypt.compare(password, hashedPassword);
}
```

### 2. API输入验证中间件

#### 修复方案
```javascript
// 安装验证库
npm install joi express-rate-limit helmet

const Joi = require('joi');
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');

// 安全中间件
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"]
    }
  }
}));

// API限流
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 100, // 限制每个IP 15分钟内最多100个请求
  message: {
    success: false,
    message: '请求过于频繁，请稍后再试'
  }
});

app.use('/api/', apiLimiter);

// 输入验证中间件
function validateInput(schema) {
  return (req, res, next) => {
    const { error } = schema.validate(req.body);
    if (error) {
      return res.status(400).json({
        success: false,
        message: '输入数据验证失败',
        details: error.details.map(detail => detail.message)
      });
    }
    next();
  };
}

// 聊天消息验证schema
const chatMessageSchema = Joi.object({
  message: Joi.string().min(1).max(10000).required(),
  model: Joi.string().valid('gpt-4o', 'o3', 'gemini-2.5-pro-thinking', 'claude-3.7-sonnet', 'deepseek-r1', 'deepseek-v3').optional(),
  conversation_id: Joi.string().uuid().optional(),
  temperature: Joi.number().min(0).max(2).optional(),
  max_tokens: Joi.number().min(1).max(8192).optional()
});

// 应用验证
app.post('/api/chat/send', validateInput(chatMessageSchema), async (req, res) => {
  // 安全的处理逻辑
});
```

### 3. 敏感信息环境变量化

#### 修复方案
```javascript
// 创建 .env 文件
AI_API_KEY=your_actual_api_key_here
AI_BASE_URL=https://hk-intra-paas.transsion.com/tranai-proxy/v1
JWT_SECRET=your_super_secret_jwt_key_here
DB_PASSWORD=your_database_password_here
REDIS_PASSWORD=your_redis_password_here

// 更新配置文件
require('dotenv').config();

const AI_CONFIGS = {
  'gpt-4o': {
    name: 'GPT-4o',
    model: 'gpt-4o',
    apiKey: process.env.AI_API_KEY, // 从环境变量读取
    baseURL: process.env.AI_BASE_URL,
    maxTokens: 4096,
    temperature: 0.7
  }
  // ... 其他配置
};

// 启动时检查必要的环境变量
function checkRequiredEnvVars() {
  const required = ['AI_API_KEY', 'JWT_SECRET', 'AI_BASE_URL'];
  const missing = required.filter(key => !process.env[key]);
  
  if (missing.length > 0) {
    console.error('❌ 缺少必要的环境变量:', missing.join(', '));
    process.exit(1);
  }
}

checkRequiredEnvVars();
```

### 4. SQL注入防护

#### 修复方案
```javascript
// 使用参数化查询
const sqlite3 = require('sqlite3').verbose();

// 错误示例（存在SQL注入风险）
// const query = `SELECT * FROM users WHERE username = '${username}'`;

// 正确示例（参数化查询）
function getUserByUsername(username) {
  return new Promise((resolve, reject) => {
    const query = 'SELECT * FROM users WHERE username = ?';
    db.get(query, [username], (err, row) => {
      if (err) {
        reject(err);
      } else {
        resolve(row);
      }
    });
  });
}

// 批量操作也要使用参数化查询
function insertChatHistory(records) {
  const query = `
    INSERT INTO chat_history (id, user_id, message, response, timestamp)
    VALUES (?, ?, ?, ?, ?)
  `;
  
  const stmt = db.prepare(query);
  
  records.forEach(record => {
    stmt.run([record.id, record.userId, record.message, record.response, record.timestamp]);
  });
  
  stmt.finalize();
}
```

### 5. XSS防护

#### 前端修复
```javascript
// 安装XSS防护库
npm install dompurify

import DOMPurify from 'dompurify';

// 输出时进行HTML转义
function sanitizeHtml(html) {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br'],
    ALLOWED_ATTR: ['href']
  });
}

// Vue组件中使用
export default {
  methods: {
    renderMessage(message) {
      return sanitizeHtml(message);
    }
  }
}
```

#### 后端修复
```javascript
// 安装转义库
npm install escape-html

const escapeHtml = require('escape-html');

// API响应时转义HTML
app.post('/api/chat/send', async (req, res) => {
  try {
    const { message } = req.body;
    
    // 转义用户输入
    const safeMessage = escapeHtml(message);
    
    // 处理AI响应
    const aiResponse = await callAIAPI(safeMessage);
    
    res.json({
      success: true,
      data: {
        message: safeMessage,
        response: escapeHtml(aiResponse.content)
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: '服务器错误'
    });
  }
});
```

### 6. CSRF防护

#### 修复方案
```javascript
// 安装CSRF防护中间件
npm install csurf

const csrf = require('csurf');

// 配置CSRF保护
const csrfProtection = csrf({
  cookie: {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict'
  }
});

// 应用CSRF保护到需要的路由
app.use('/api/admin/', csrfProtection);
app.use('/api/config/', csrfProtection);

// 提供CSRF token给前端
app.get('/api/csrf-token', csrfProtection, (req, res) => {
  res.json({
    success: true,
    csrfToken: req.csrfToken()
  });
});
```

### 7. 安全配置加强

#### 修复方案
```javascript
// 安全配置
app.use(helmet({
  // 内容安全策略
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "https://api.openai.com"]
    }
  },
  // 强制HTTPS
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}));

// 隐藏服务器信息
app.disable('x-powered-by');

// 设置安全头
app.use((req, res, next) => {
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  next();
});
```

## 📋 修复实施计划

### 第一周（P0优先级）
- [ ] JWT认证机制标准化
- [ ] 移除硬编码敏感信息
- [ ] 添加基础输入验证

### 第二周（P1优先级）
- [ ] 实现API限流
- [ ] SQL注入防护
- [ ] XSS防护机制

### 第三周（P2优先级）
- [ ] CSRF防护
- [ ] 安全配置加强
- [ ] 安全测试验证

### 第四周（验证和文档）
- [ ] 安全测试
- [ ] 文档更新
- [ ] 团队培训

## 🧪 安全测试验证

### 自动化安全测试
```bash
# 安装安全测试工具
npm install --save-dev jest supertest

# 创建安全测试用例
describe('Security Tests', () => {
  test('should reject invalid JWT tokens', async () => {
    const response = await request(app)
      .get('/api/protected')
      .set('Authorization', 'Bearer invalid-token');
    
    expect(response.status).toBe(401);
  });
  
  test('should prevent SQL injection', async () => {
    const maliciousInput = "'; DROP TABLE users; --";
    const response = await request(app)
      .post('/api/login')
      .send({ username: maliciousInput, password: 'test' });
    
    expect(response.status).toBe(400);
  });
});
```

这个修复方案解决了检查中发现的主要安全漏洞，建议按照优先级逐步实施。
